---
date: 2025-09-02T23:58:12.158792+09:00
researcher: Codex CLI
git_commit: 013916e2bf4c7c33f0cf2b0f45b7ada4ec14edb9
branch: main
repository: nandseqgen_v2
topic: "각각의 요소의 인터페이스를 구상하고 요소별로 독립적으로 검증을 한 다음 순차적으로 통합한다고 할 때, 각 요소별 인터페이스를 어떻게 디자인해야 요소마다 가지고 있는 복잡성을 최대한 분리해서 구현할 수 있을까?"
tags: [research, codebase, scheduler, proposer, resourcemanager, addressmanager, validator, cfg]
status: complete
last_updated: 2025-09-02
last_updated_by: Codex CLI
---

# 연구: 요소별 인터페이스 설계로 복잡성 분리

**Date**: 2025-09-02T23:58:12.158792+09:00
**Researcher**: Codex CLI
**Git Commit**: 013916e2bf4c7c33f0cf2b0f45b7ada4ec14edb9
**Branch**: main
**Repository**: nandseqgen_v2

## 연구 질문
각각의 요소의 인터페이스를 구상하고 요소별로 독립적으로 검증을 한 다음 순차적으로 통합한다고 할 때, 각 요소별 인터페이스를 어떻게 디자인해야 요소마다 가지고 있는 복잡성을 최대한 분리해서 구현할 수 있을까?

## 요약
- 핵심 원칙: 불변 DTO + 순수 함수 경계 + 트랜잭션형 리소스 커밋. 시간/난수는 주입하고, 상태 변경은 한 곳(리소스 커밋 경계)에서만 발생하게 한다.
- 구성요소 경계: Proposer/Validator는 순수(read‑only)하며, Scheduler가 트랜잭션으로 예약→검증→커밋을 수행. AddressManager는 “샘플링(순수)”과 “적용(커밋)”을 분리. CFG는 런타임 전 정규화된 불변 뷰 제공.
- 테스트성: 각 구성요소는 입력→출력이 결정적인 인터페이스를 노출하고, 부수효과/시간/RNG는 의존성 주입으로 격리해 독립 테스트를 가능하게 한다.

## 상세 발견

### Data classes (DTO 경계)
- Operation/Address/StateSeg는 얕은(pydantic/dataclass) DTO로 유지. I/O나 전역을 포함하지 않음.
- 불변/가벼운 비교가 가능한 형태로 두어 캐싱/테스트 용이성 확보.
- 참조: `docs/PRD_v2.md:99` Address/StateSeg/Operation 초안.

제안 인터페이스 스케치
- `Address(die:int, plane:int, block:int, page:Optional[int])`
- `StateSeg(name:str, dur_us:float, bus:bool=False)`
- `Operation(op_id:int, op_name:str, op_base:str, payload:dict, target:List[Address], states:List[StateSeg], source:str, meta:dict={})`

### CFG (정규화된 불변 뷰)
- 목적: YAML을 읽은 뒤 파생 키(`op_specs`, `groups_by_base`, `phase_conditional`)를 채운 단일 진실의 불변 뷰 제공.
- 인터페이스
  - `compile_cfg(yaml_dict) -> Cfg`: 전체 정규화 + 검증. 결과는 해시 가능하거나 최소한 복사 없이 읽기 전용 사용.
  - `Cfg.view`: dict‑like read‑only; 내부 포인터나 가변 컬렉션은 노출 금지.
- 참조: `docs/PRD_v2.md:141` 정규화 규칙 및 자동 채움 정책.

### AddressManager (주소 상태/샘플링)
- 역할 분리: 샘플러(pure) vs 적용(commit). 같은 객체 내에서도 메서드 레벨로 경계 노출.
- 인터페이스
  - Pure
    - `sample_erase(spec) -> List[Address]`
    - `sample_program(spec, sequential:bool=False) -> List[List[Address]]`
    - `sample_read(spec) -> List[List[Address]]`
    - 입력 spec에는 `plane_set/die/mode/size` 등 제약을 명시(불변 DTO).
  - Commit
    - `apply_erase(txn, addrs)` / `apply_program(txn, addrs)` / `apply_read(txn, addrs)`
  - Txn은 ResourceManager가 제공하는 트랜잭션 핸들로, AddressManager는 내부 상태(diff)를 그 Txn에만 기록하고 commit 시 반영.
- 참고 구현: `addrman.py:65` 클래스, `addrman.py:405` `random_erase`, `addrman.py:490` `random_pgm`, `addrman.py:342` `from_topology`.

### Validator (규칙 평가; 순수)
- 입력: `BatchProposal`(operations+tentative schedule), `ResourceView`, `Cfg`.
- 출력: `ValidationReport`(per‑op pass/fail, reasons, first_conflict_time 등). 부수효과 없음.
- 세부 체크: epr_dependencies, IO_bus_overlap, exclusion_window_violation, latch, ODT, scope 등.
- 참조: `docs/PRD_v2.md:345` 항목 목록.

제안 인터페이스 스케치
- `validate(batch: ProposedBatch, res: ResourceView, cfg: Cfg) -> ValidationReport`

### ResourceManager (권위 있는 상태 + 트랜잭션)
- 역할: 모든 타임라인/버스/래치/배제창/ongoing_ops의 단일 진실. 예약과 커밋은 트랜잭션으로 수행.
- 인터페이스
  - 읽기 전용 뷰: `ResourceView`(불변 스냅샷). 질의 메서드만 제공(`is_bus_free`, `window_for(die,plane)`, `timeline_at(...)`).
  - 트랜잭션: `begin_txn() -> Txn`; `reserve(txn, op, when)`, `commit(txn)`, `rollback(txn)`.
  - 이벤트 후크: `apply(op, schedule)`이 커밋 시 StateTimeline/배제윈도우/버스/래치 갱신.
- 스냅샷 연동: DTO로 dump/load, RNG 상태 별도 보관(3.6 참조).
- 참조: `docs/PRD_v2.md:284` 리소스 항목, 타임라인 관리.

### Proposer (확률적 제안; 순수)
- 입력: `(now, hook:PhaseHook, res:ResourceView, cfg:Cfg, rng:RngStream)`.
- 출력: `ProposedBatch`(sequence 확장 포함, 전부 또는 없음 규칙 준수). 상태 변경 없음.
- 설계 포인트
  - RNG 스트림 주입: `(global_seed, hook_counter)`에서 분기한 스트림만 사용.
  - 후보 생성 → address 샘플 → 사전검증(Validator 호출) → 실패 시 대안 샘플 재시도.
- 참조: `docs/PRD_v2.md:248` 워크플로, 확률 규칙.

제안 인터페이스 스케치
- `propose(now:float, hook:PhaseHook, res:ResourceView, cfg:Cfg, rng:Rng) -> ProposedBatch | None`

### Scheduler (이벤트 구동 + 커밋 경계)
- 책임: 시간 전진, 훅 호출, 배치 예약, 트랜잭션 경계/커밋, PHASE_HOOK 생성.
- 인터페이스
  - `tick() -> Stats`: 내부 heap에서 훅 pop → Proposer 호출 → Validator 통과 시 `begin_txn→reserve→commit`.
  - `schedule(batch:ProposedBatch) -> ScheduleResult`: 단일 진입점. 동일 틱 내 부분 스케줄 금지 원칙 반영.
  - 관측: 구조화 로깅과 메트릭 노출(성공률, 큐 기아, 윈도우 충돌 등).
- 참조: `docs/PRD_v2.md:210` 스케줄러 설계; 구현체 예시 `nandsim_demo.py:2394`.

### 공통 교차 관심사
- RNG: `RngStream(seed, path_id)` 인터페이스로 구성요소에 주입. 시스템 시간 금지.
- 시간: 이벤트 훅 기반으로만 전진. AdmissionWindow는 Scheduler가 적용.
- 예외/오류: Validator는 “사실 보고” 중심. 예외는 비정상/불가복 상황에만 사용.
- 로깅: 민감정보 금지, op_id/seq/phase 를 상관관계 키로 사용.

## 코드 참조
- `docs/PRD_v2.md:97` - Architecture & Components 개요.
- `docs/PRD_v2.md:99` - Data classes 초안.
- `docs/PRD_v2.md:141` - CFG 정규화/자동 채움.
- `docs/PRD_v2.md:210` - Scheduler 설계.
- `docs/PRD_v2.md:248` - Proposer 워크플로.
- `docs/PRD_v2.md:284` - ResourceManager 역할.
- `docs/PRD_v2.md:327` - AddressManager 범위.
- `docs/PRD_v2.md:345` - Validator 체크 항목.
- `addrman.py:65` - AddressManager 클래스 정의.
- `addrman.py:342` - `from_topology` 초기화 유틸.
- `addrman.py:405` - `random_erase` 샘플링/적용.
- `addrman.py:490` - `random_pgm` 샘플링/적용.
- `nandsim_demo.py:2394` - Scheduler 구현 시작.

## 아키텍처 인사이트
- 복잡성 분리는 “순수(샘플/검증)”와 “커밋(상태변경)”의 분기에서 시작한다. 주소/자원/시간은 커밋 경계에서만 변해야 한다.
- DTO를 통한 캡슐화는 경계를 얇고 명확하게 하며, 테스트를 간단하게 만든다.
- 트랜잭션 스냅샷/롤백을 통해 부분 실패를 안전하게 다루고, 동일 틱 내 원자성을 보장한다.
- CFG는 불변/정규화 뷰로 제공해 의사결정의 단일 진실을 강제한다.

## 역사적 맥락(thoughts/ 기반)
- thoughts/ 디렉터리는 확인되지 않음. 문서 기반으로 정리함.

## 관련 연구
- 없음

## 미해결 질문
- 예약된 operation과 runtime 제안 operation의 우선순위 조정(스케줄러 정책): `docs/PRD_v2.md:8`의 Open Questions. 단일 rail에서 “예약 안정성 보장 + 무해한 동시 제안 허용” 정책이 유력.

