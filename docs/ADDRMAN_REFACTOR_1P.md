# Problem 1‑Pager — AddressManager Sampling Refactor

- 배경: `addrman.py`는 ERASE/PGM/READ 후보를 전개(expand)한 뒤 샘플링합니다. 특히 READ의 경우 `(block, 0..readmax)` 전체를 나열하여 대규모 배열을 생성하고, PGM/READ 연속 샘플링은 배열 슬라이싱과 루프 탐색으로 처리되어 런타임 비용이 큽니다. 또한 모듈 하단 데모 코드가 항상 실행되어(수정 전 `if 1==1:`) 불필요한 import/실행 부하가 있습니다.

- 문제: 
  - 후보 완전 전개로 인한 메모리/시간 오버헤드(READ가 특히 심각)
  - 연속 샘플링의 선형 탐색 비용
  - `random_*`가 `get_*`/`sample_*`/`set_*`를 연쇄 호출하여 중복 계산
  - 프로그램(연속) 시 동일 블록 중복 인덱싱으로 누적 증가가 1회로 처리될 위험(NumPy 팬시 인덱싱 특성)
  - 모듈 import 시 시각화 의존성 로드 및 데모 실행 (부수효과)

- 목표:
  - 후보 전개 없이 가중치 샘플링으로 직접 대상 생성 (특히 READ)
  - 멀티‑플레인 샘플링을 그룹 단위로 벡터화
  - `random_*`를 단일 패스(샘플+적용)로 구현하여 중복 제거
  - PGM 연속 샘플링 시 상태를 +size로 정확히 갱신
  - import 부하 제거(시각화는 지연 import), 데모는 `__main__` 가드
  - 외부 API의 기본 반환 형태(shape)는 유지 ((#,1,2) 또는 (#,k,2))

- 비목표:
  - 기존 `get_*`/`sample_*`/`set_*` API의 내부 동작 전면 교체(호환성 위해 유지)
  - nandsim 통합(`plan_multiplane`)은 다음 단계에서 수행
  - 시각화 기능 고도화(단, 지연 import만 적용)

- 제약:
  - NumPy 사용(네트워크/빌드 제한 환경)
  - 멀티‑플레인 그룹핑은 기존 구현 가정 유지(`num_blocks % num_planes == 0`)
  - 코드 외부에서 `arr_to_nparr` 등 유틸을 import하므로 보존 필요

- 대안 비교:
  1) 후보 전개 유지 + 파이썬 최적화
     - 장점: 변경 폭 작음, 위험 낮음
     - 단점: READ/멀티‑플레인 비용 근본적 개선 어려움
     - 위험: 메모리 폭증 지속
  2) 인덱스/가중치 기반 직접 샘플링(선택)
     - 장점: 전개 비용 제거, 선형→아핀/로그 시간
     - 단점: 구현 복잡도 상승, 라인 번호 문서 최신화 필요
     - 위험: 멀티‑플레인 로직 정확도 검증 필요

- 결정: (2) 채택. 
  - 사전계산: `self._plane_index`, 지연계산 `self._block_groups`(그룹 행렬)
  - READ 가중치 샘플링: 누적합(cumsum) + `searchsorted`로 O(k log n)
  - 연속 샘플링: 블록별 시작가능 개수로 가중치 샘플링
  - `random_*`가 직접 상태 갱신 및 undo 스냅샷 기록
  - 시각화는 함수 내부 지연 import, 데모는 `__main__` 가드

- 위험/완화:
  - 그룹핑 제약: 기존과 동일하게 나눠떨어지지 않으면 예외(조기 실패로 문제 노출)
  - 문서 라인 번호: 함수 기반 서술로 업데이트 예정
  - 회귀 위험: 반환 shape 유지, 기본 모드/조건 동일하게 필터링

- 다음 단계:
  - `nandsim_demo.py`의 `AddressManager.plan_multiplane` 호출 경로에 본 샘플링 로직을 주입
  - 라인 번호 참조 제거/정리로 워크플로 문서 최신화
  - 소규모 벤치(페이지 크기/블록 수 스윕)로 전/후 성능 수치화

---
업데이트(v2): 벤치 승인 후 legacy API 제거
- 배경: 벤치로 random_* 경로가 충분히 검증되어 get_*/sample_*/set_adds_* 유지 비용이 정당화되지 않음.
- 조치: `get_*`, `sample_*`, `set_adds_*` 및 관련 내부 `_get_*` 구현을 제거. 공개 API는 `random_erase/random_pgm/random_read` 중심으로 단순화.
- 영향: 워크플로 문서 일부(legacy 경로 설명)는 참고용으로 보존하되, 실제 사용은 random_*를 따름. 벤치 스크립트는 fast path만 측정하도록 갱신.
