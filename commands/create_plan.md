# 구현 계획

대화형이고 반복적인 과정을 통해 상세한 구현 계획을 작성하는 임무를 수행합니다. 회의적이되 철저하게, 그리고 사용자와 협업하여 고품질의 기술 명세를 도출해야 합니다.

## 초기 응답

이 명령이 호출되면:

1. **매개변수 제공 여부 확인**:
   - 매개변수로 파일 경로가 제공되었다면 기본 메시지는 생략합니다
   - 제공된 파일을 즉시 "완전히" 읽습니다
   - 연구 프로세스를 시작합니다

2. **매개변수가 없다면** 다음과 같이 응답하세요:
```
상세한 구현 계획 작성을 도와드릴게요. 무엇을 만들지부터 파악하겠습니다.

다음을 알려주세요:
1. 작업 설명(또는 파일 참조)
2. 관련된 맥락, 제약, 구체 요구사항
3. 관련 연구나 이전 구현 링크

제공해주신 정보를 분석해 함께 포괄적인 계획을 만들겠습니다.
```

그 후 사용자의 입력을 기다립니다.

## 프로세스 단계

### 1단계: 맥락 수집 및 초기 분석

1. **언급된 모든 파일을 즉시 그리고 완전히 읽기**:
   - 연구 문서
   - 관련 구현 계획
   - 언급된 모든 JSON/데이터 파일
   - **중요**: 전체 파일을 읽기 위해 Read 도구를 limit/offset 없이 사용합니다
   - **치명적**: 이 파일들을 메인 컨텍스트에서 직접 읽기 전에는 하위 작업을 생성하지 않습니다
   - **절대** 부분만 읽지 않습니다 — 언급된 파일은 전부 읽습니다

2. **맥락 수집을 위한 초기 연구 작업 생성**:
   사용자의 질문을 하기 전에, 에이전트들을 병렬로 사용하여 조사합니다:

   - 작업과 관련된 모든 파일 찾기
   - 현재 구현이 어떻게 동작하는지 이해하기
   - 관련이 있다면 이 기능에 대한 기존 research 문서 찾기

   이 에이전트들은 다음을 수행합니다:
   - 관련 소스, 구성, 테스트 파일 찾기
   - 집중할 구체적 디렉터리 식별
   - 데이터 흐름과 핵심 함수 추적
   - 파일:줄 참조를 포함한 상세 설명 반환

3. **연구 작업이 식별한 모든 파일 읽기**:
   - 연구 작업이 완료된 후, 관련하다고 식별된 모든 파일을 읽습니다
   - 메인 컨텍스트에 "완전히" 읽어들입니다
   - 이렇게 해야 다음 단계로 진행하기 전에 완전한 이해가 보장됩니다

4. **분석 및 이해 검증**:
   - 불일치나 오해가 없는지 식별합니다
   - 검증이 필요한 가정을 기록합니다
   - 코드베이스의 실제 상태를 기반으로 범위를 확정합니다

5. **근거 있는 이해와 집중 질문 제시**:
   ```
   코드베이스 조사를 바탕으로, 우리가 해야 할 일은 [정확한 요약]라고 이해했습니다.

   조사 결과:
   - [파일:줄 참조가 포함된 현재 구현 상세]
   - [발견된 관련 패턴 또는 제약]
   - [잠재적 복잡도나 엣지 케이스]

   코드 조사만으로 답할 수 없었던 질문:
   - [인간 판단이 필요한 구체 기술 질문]
   - [비즈니스 로직 명확화]
   - [구현에 영향을 주는 설계 선호]
   ```

   코드 조사를 통해 답할 수 없는 질문만 하십시오.

### 2단계: 연구 및 발견

초기 명확화를 받은 후:

1. **사용자가 오해를 정정한 경우**:
   - 단순히 정정을 수용하지 않습니다
   - 사실 확인을 위해 새로운 연구 작업을 생성합니다
   - 사용자가 언급한 특정 파일/디렉터리를 읽습니다
   - 직접 사실을 검증한 후에만 진행합니다

2. **연구 할 일 목록**을 TODO list로 만들어 탐색 작업을 추적합니다

3. **포괄적 연구를 위한 병렬 하위 작업 생성**:
   - 여러 Task 에이전트를 만들어 서로 다른 측면을 동시에 조사합니다
   - 연구 유형에 맞는 적절한 에이전트를 사용합니다:

   **심화 조사용:**
   - 더 구체적인 파일 찾기(예: "[특정 컴포넌트]를 다루는 모든 파일 찾기")
   - 구현 세부 이해(예: "[시스템]의 동작 분석")
   - 모델로 삼을 유사 기능 찾기

   **역사적 맥락용:**
   - 해당 영역에 대한 연구, 계획, 결정 찾기
   - 가장 관련성 높은 문서에서 핵심 인사이트 추출

   각 에이전트는 다음을 수행할 줄 압니다:
   - 올바른 파일과 코드 패턴 찾기
   - 따라야 할 관례와 패턴 식별
   - 통합 지점과 의존성 찾기
   - 구체적 파일:줄 참조 반환
   - 테스트와 예시 찾기

3. **모든 하위 작업이 완료될 때까지 대기** 후 진행

4. **발견 사항과 설계 옵션 제시**:
   ```
   조사 결과는 다음과 같습니다:

   **현재 상태:**
   - [기존 코드에 대한 핵심 발견]
   - [따라야 할 패턴 또는 관례]

   **설계 옵션:**
   1. [옵션 A] - [장단점]
   2. [옵션 B] - [장단점]

   **미결 질문:**
   - [기술적 불확실성]
   - [필요한 설계 결정]

   어떤 접근이 당신의 목표에 가장 잘 부합하나요?
   ```

### 3단계: 계획 구조 개발

접근 방식에 합의했다면:

1. **초기 계획 개요 작성**:
   ```
   제안하는 계획 구조입니다:

   ## 개요
   [1~2문장 요약]

   ## 구현 단계:
   1. [단계명] - [달성 내용]
   2. [단계명] - [달성 내용]
   3. [단계명] - [달성 내용]

   이 단계 구성이 타당한가요? 순서나 granularity를 조정할까요?
   ```

2. **세부를 작성하기 전에 구조에 대한 피드백 수집**

### 4단계: 상세 계획 작성

구조 승인을 받은 후:

1. **계획을 작성**하여 `plans/{descriptive_name}.md`에 저장합니다
2. **다음 템플릿 구조를 사용**합니다:

```markdown
# [기능/작업 이름] 구현 계획

## 개요

[무엇을 왜 구현하는지의 간략 설명]

## 현재 상태 분석

[현재 존재하는 것, 부족한 것, 발견된 핵심 제약]

## 목표 상태

[이 계획 완료 후 기대 상태의 명세와 검증 방법]

### 핵심 발견:
- [파일:줄 참조를 포함한 중요 발견]
- [따라야 할 패턴]
- [준수해야 할 제약]

## 범위에서 제외되는 항목

[스코프 크립을 막기 위해 명시적으로 제외할 항목]

## 구현 접근

[상위 수준 전략과 근거]

## 1단계: [설명적 이름]

### 개요
[이 단계가 달성하는 바]

### 필요한 변경:

#### 1. [컴포넌트/파일 그룹]
**File**: `path/to/file.ext`
**Changes**: [변경 요약]

```[language]
// 추가/수정할 구체 코드
```

### 성공 기준:

#### 자동 검증:
- [ ] 마이그레이션이 깔끔히 적용됨
- [ ] 단위 테스트 통과
- [ ] 통합 테스트 통과

#### 수동 검증:
- [ ] 기능이 기대대로 동작함
- [ ] 부하 상황에서도 성능 허용 범위
- [ ] 엣지 케이스 수동 확인 완료
- [ ] 관련 기능에 회귀 없음

---

## 2단계: [설명적 이름]

[자동/수동 성공 기준을 포함한 유사한 구조...]

---

## 테스트 전략

### 단위 테스트:
- [무엇을 테스트할지]
- [핵심 엣지 케이스]

### 통합 테스트:
- [E2E 시나리오]

### 수동 테스트 단계:
1. [기능을 검증할 구체 단계]
2. [다른 검증 단계]
3. [수동으로 확인할 엣지 케이스]

## 성능 고려사항

[성능 영향이나 필요한 최적화]

## 마이그레이션 노트

[해당 시, 기존 데이터/시스템 처리 방법]

## 참고 자료

- 관련 연구: `research/[relevant].md`
- 유사 구현: `[file:line]`
```

### 5단계: 동기화 및 검토

1. **초안 계획 위치 공유**:
   ```
   초기 구현 계획을 다음 위치에 생성했습니다:
   `plans/[filename].md`

   검토 후 알려주세요:
   - 단계 스코프가 적절한가요?
   - 성공 기준이 충분히 구체적인가요?
   - 조정이 필요한 기술적 사항이 있나요?
   - 누락된 엣지 케이스나 고려사항이 있나요?
   ```

2. **피드백에 따라 반복** — 다음에 대비하세요:
   - 누락된 단계 추가
   - 기술적 접근 조정
   - 성공 기준(자동 및 수동) 명확화
   - 스코프 항목 추가/삭제

3. **사용자가 만족할 때까지 계속 정련**

## 중요한 가이드라인

1. **회의적일 것**:
   - 모호한 요구사항을 질문하기
   - 잠재적 이슈를 조기에 식별하기
   - "왜?"와 "그렇다면?"을 묻기
   - 가정하지 말고 코드로 검증하기

2. **상호작용적일 것**:
   - 한 번에 전체 계획을 작성하지 않기
   - 주요 단계마다 동의를 얻기
   - 방향 수정 허용하기
   - 협업적으로 일하기

3. **철저할 것**:
   - 계획 전에 모든 맥락 파일을 "완전히" 읽기
   - 병렬 하위 작업으로 실제 코드 패턴 조사
   - 구체적 파일 경로와 줄 번호 포함
   - 자동/수동을 명확히 구분한 측정 가능한 성공 기준 작성

4. **실용적일 것**:
   - 점진적이고 테스트 가능한 변경에 집중
   - 마이그레이션과 롤백 고려
   - 엣지 케이스 고려
   - "하지 않을 것들" 포함

5. **진행 상황 추적**:
   - TodoWrite를 사용해 계획 작업 추적
   - 연구를 완료할 때마다 todo 갱신
   - 계획 작업 완료 시 완료 표시

6. **최종 계획에는 미해결 질문이 없을 것**:
   - 계획 중 미해결 질문을 만나면, 즉시 중단
   - 즉시 연구하거나 명확화를 요청
   - 미해결 상태로 계획을 작성하지 않기
   - 구현 계획은 완전하고 실행 가능해야 함
   - 모든 결정은 최종화 전에 내려져야 함

## 성공 기준 가이드라인

**성공 기준은 항상 두 범주로 분리합니다:**

1. **자동 검증**(실행 에이전트가 수행 가능):
   - 실행 가능한 명령: `make test`, `npm run lint` 등
   - 존재해야 하는 구체 파일
   - 자동화된 테스트 스위트

2. **수동 검증**(사람의 테스트 필요):
   - 실제 조건에서의 성능
   - 자동화하기 어려운 엣지 케이스
   - 사용자 수용 기준

**형식 예시:**
```markdown
### 성공 기준:

#### 자동 검증:
- [ ] 모든 단위 테스트 통과: `go test ./...`

#### 수동 검증:
- [ ] 1000개 이상의 항목에서도 성능 허용 범위
- [ ] 오류 메시지가 사용자 친화적임
```

## 공통 패턴

### 데이터베이스 변경의 경우:
- 스키마/마이그레이션부터 시작
- 저장소 메서드 추가
- 비즈니스 로직 업데이트
- API로 노출
- 클라이언트 업데이트

### 신규 기능의 경우:
- 먼저 기존 패턴 조사
- 데이터 모델부터 시작
- 백엔드 로직 구성
- API 엔드포인트 추가
- UI는 마지막에 구현

### 리팩터링의 경우:
- 현재 동작 문서화
- 점진적 변경 계획
- 하위 호환성 유지
- 마이그레이션 전략 포함

## 하위 작업 생성 모범 사례

연구 하위 작업을 생성할 때:

1. **여러 작업을 병렬 생성**하여 효율을 높입니다
2. **각 작업은 특정 영역에 집중**하도록 합니다
3. **상세 지시를 제공**합니다:
   - 정확히 무엇을 검색할지
   - 어떤 디렉터리에 집중할지
   - 어떤 정보를 추출할지
   - 기대되는 출력 형식
4. **디렉터리에 대해 매우 구체적일 것**:
   - 프롬프트에 전체 경로 맥락을 포함합니다
5. **읽기 전용 도구를 지정**합니다
6. **응답에 구체적 파일:줄 참조를 요구**합니다
7. **모든 작업 완료를 대기**한 뒤 종합합니다
8. **하위 작업 결과를 검증**합니다:
   - 예기치 않은 결과가 오면 후속 작업 생성
   - 실제 코드베이스와 교차 확인
   - 신뢰하기 어려운 결과는 수용하지 않기
